#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# 
# Zimbra Collaboration Suite Server
# Copyright (C) 2005, 2006, 2007 Zimbra, Inc.
# 
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use lib "/opt/zimbra/zimbramon/lib";
use Zimbra::Util::Common;
use File::Grep qw (fgrep);
use Net::LDAP;
use Net::LDAP::LDIF;
use Net::LDAP::Entry;
use Crypt::SaltedHash;
use MIME::Base64;

my $source_config_dir = "/opt/zimbra/openldap/etc/openldap";
my $config_dir = "/opt/zimbra/conf";

my $zimbra_home=getLocalConfig("zimbra_home");
my $zimbra_ldap_userdn = getLocalConfig("zimbra_ldap_userdn");
my $zimbra_ldap_password = getLocalConfig("zimbra_ldap_password");
my $ldap_root_password = getLocalConfig("ldap_root_password");
my $ldap_master_url = getLocalConfig("ldap_master_url");

# Get the SHA password.
my $ctx = Crypt::SaltedHash->new(algorithm => 'SHA-1');
$ctx->add("$ldap_root_password");
my $root_ssha_password = $ctx->generate;

$ctx = Crypt::SaltedHash->new(algorithm => 'SHA-1');
$ctx->add("$zimbra_ldap_password");
my $zimbra_ssha_password = $ctx->generate;

# Update slapd.conf
my $infile="$source_config_dir/slapd.conf";
my $outfile="$config_dir/slapd.conf.in";

open(IN,"<$infile");
open(OUT,">$outfile");
while (<IN>) {
  if ($_ =~ /^rootpw/) {
    $_ =~ s|^rootpw.*|rootpw $root_ssha_password|;
    print OUT $_;
  } else {
    print OUT $_;
  }
}
close IN;
close OUT;

# Add zimbra-ext schema if needed
if ( -f "/opt/zimbra/lib/conf/zimbra-ext.schema") {
   if ( !fgrep { /zimbra-ext.schema/ } "${config_dir}/slapd.conf.in" ) {
      $infile="${config_dir}/slapd.conf.in";
      $outfile="/tmp/slapd.conf.$$";
      
      open(IN,"<$infile");
      open(OUT,">$outfile");
      while (<IN>) {
         if ($_ =~ /\/opt\/zimbra\/openldap\/etc\/openldap\/schema\/zimbra.schema/) {
            print OUT $_;
            print OUT "include\t\t\"/opt/zimbra/lib/conf/zimbra-ext.schema\"";
            print OUT "\n";
         } else {
            print OUT $_;
         }
      }
      close OUT;
      close IN;
      if ( -s $outfile ) {
         my $rc=0xffff & system("/bin/mv -f $infile $infile.bak");
         if ($rc != 0) {
            print "Warning: Failed to backup $infile\n";
         }
         $rc=0xffff & system("/bin/mv -f $outfile $infile");
         if ($rc != 0) {
            print "Failed to move $outfile to $infile\nRestoring old configuration\n";
            $rc=0xffff & system("/bin/mv -f $infile.bak $infile");
            if ($rc != 0) {
               print "Failed to restore backup\n";
            }
         } else {
            system("/bin/rm -f $infile.bak");
         }
      }
   }
}

# Update zimbra.ldif
unlink("${config_dir}/zimbra.ldif");

# Update zimbra.ldif
$infile = "$source_config_dir/zimbra.ldif";
$outfile = "$config_dir/zimbra.ldif";
my $ldifin = Net::LDAP::LDIF->new( "$infile", "r", onerror => 'undef' );
my $ldifout = Net::LDAP::LDIF->new("$outfile", "w", onerror => 'undef' );
while( not $ldifin->eof()) {
  my $entry = $ldifin->read_entry ( );
  if ( $ldifin->error ( ) ) {
    print "Error msg: ", $ldifin->error ( ), "\n";
    print "Error lines:\n", $ldifin->error_lines ( ), "\n";
  } else {
      if ($entry->dn() eq "uid=zimbra,cn=admins,cn=zimbra") {
        $entry->replace (
          userPassword => "${zimbra_ssha_password}",
        );
      }
    $ldifout->write($entry);
  }
}
$ldifin->done ( );
$ldifout->done ( );

# Start ldap
my $rc=`${zimbra_home}/bin/ldap start`;
if ( $rc eq 0 ) {
        exit 1;
}

my $ldap = Net::LDAP->new("${ldap_master_url}")  or  die "$@";

# startTLS Operation
my $mesg;
if ($ldap_master_url !~ /^ldaps/i) {
   $mesg = $ldap->start_tls(
        verify => 'none',
        capath => "${zimbra_home}/conf/ca",
        ) or die "start_tls: $@";
   $mesg->code && die "TLS: " . $mesg->error . "\n";
}

$mesg = $ldap->bind("cn=config", password=>"$ldap_root_password");

$infile = "$config_dir/zimbra.ldif";
$ldifin = Net::LDAP::LDIF->new("$infile", "r", onerror => 'undef' );
while ( not $ldifin->eof() ) {
    my $entry = $ldifin->read_entry();
    if ( $ldifin->error() ) {
      print "Error msg: ", $ldifin->error ( ), "\n";
      print "Error lines:\n", $ldifin->error_lines ( ), "\n";
    } else {
      $entry->changetype("add");
      $entry->update($ldap);
    }
}

$infile = "$source_config_dir/zimbra_globalconfig.ldif";
$ldifin = Net::LDAP::LDIF->new("$infile", "r", onerror => 'undef' );
while ( not $ldifin->eof() ) {
    my $entry = $ldifin->read_entry();
    if ( $ldifin->error() ) {
      print "Error msg: ", $ldifin->error ( ), "\n";
      print "Error lines:\n", $ldifin->error_lines ( ), "\n";
    } else {
      $entry->changetype("add");
      $entry->update($ldap);
    }
}

$infile = "$source_config_dir/zimbra_defaultcos.ldif";
$ldifin = Net::LDAP::LDIF->new("$infile", "r", onerror => 'undef' );
while ( not $ldifin->eof() ) {
    my $entry = $ldifin->read_entry();
    if ( $ldifin->error() ) {
      print "Error msg: ", $ldifin->error ( ), "\n";
      print "Error lines:\n", $ldifin->error_lines ( ), "\n";
    } else {
      $entry->changetype("add");
      $entry->update($ldap);
    }
}

$infile = "$source_config_dir/zimbra_mimehandlers.ldif";
$ldifin = Net::LDAP::LDIF->new("$infile", "r", onerror => 'undef' );
while ( not $ldifin->eof() ) {
    my $entry = $ldifin->read_entry();
    if ( $ldifin->error() ) {
      print "Error msg: ", $ldifin->error ( ), "\n";
      print "Error lines:\n", $ldifin->error_lines ( ), "\n";
    } else {
      $entry->changetype("add");
      $entry->update($ldap);
    }
}

if ( -d "/opt/zimbra/lib/conf/" ) {
    opendir(DIR, "/opt/zimbra/lib/conf") || die "can't opendir /opt/zimbra/lib/conf: $!";
    while (my $file = readdir(DIR)) {
       next unless (-f "/opt/zimbra/lib/conf/$file");
       next unless ( $file =~ m/ldif$/);
       $infile = "/opt/zimbra/lib/conf/$file";
       $ldifin = Net::LDAP::LDIF->new("$infile", "r", onerror => 'undef' );
       while ( not $ldifin->eof() ) {
            my $entry = $ldifin->read_entry();
            if ( $ldifin->error() ) {
              print "Error msg: ", $ldifin->error ( ), "\n";
              print "Error lines:\n", $ldifin->error_lines ( ), "\n";
            } else {
              $entry->update($ldap);
            }
       }
    }
    closedir DIR;
}

if ( -f "/opt/zimbra/.enable_replica" ) {
  my $rc=`${zimbra_home}/libexec/zmldapenablereplica`;
  $rc=`${zimbra_home}/bin/ldap stop`;
  $rc=`${zimbra_home}/bin/ldap start`;
}

exit 0;

sub getLocalConfig {
  my $key = shift;

  return $main::loaded{lc}{$key}
    if (exists $main::loaded{lc}{$key});

  my $val = `/opt/zimbra/bin/zmlocalconfig -x -s -m nokey ${key} 2> /dev/null`;
  chomp $val;
  $main::loaded{lc}{$key} = $val;
  return $val;
}

