#!/usr/bin/perl
#
# ***** BEGIN LICENSE BLOCK *****
#
# Zimbra Collaboration Suite Server
# Copyright (C) 2008 Zimbra, Inc.
#
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
#
# ***** END LICENSE BLOCK *****
#

# This script enables and disables proxy, and sets the default values for each case

use strict;
use lib "/opt/zimbra/zimbramon/lib";
use Zimbra::Util::Common;
use Getopt::Std;
use IPC::Open3;
use FileHandle;

my $enabledHTTPProxy;
my $enabledMailProxy;

my $id = `whoami`;
chomp $id;
if ($id ne "zimbra") {
    print STDERR "Error: must be run as zimbra user\n";
        exit (1);
}

our %options = ();
our %loaded = ();

getopts('defhmsw',\%options) or die "Unable to set options\n";

if ($options{h})  {
   usage();
   exit 1;
}

if ( $options{d} + $options{e} > 1) {
    usage();
    exit 1;
}

if (!$options{f}) {
  if ( !$options{d} && !$options{e} ) {
      usage();
      exit 1;
  }

  if ( !$options{m} && !$options{w} ) {
      usage();
      exit 1;
  }
} else {
   if ( ($options{d} || $options{e}) && (!$options{w} && !$options{m})) {
      usage();
      exit 1;
   }
}

if ($#ARGV == -1) {
    usage();
    exit 1;

}

my $hostname = $ARGV[0];

open(ZMPROV, "|zmprov -l");

if ($options{f}) {
  my $zimbraReverseProxyMailHostQuery =
        "\(\|\(zimbraMailDeliveryAddress=\${USER}\)\(zimbraMailAlias=\${USER}\)\(zimbraId=\${USER}\)\)";
  my $zimbraReverseProxyDomainNameQuery =
        '\(\&\(zimbraVirtualIPAddress=\${IPADDR}\)\(objectClass=zimbraDomain\)\)';
  my $zimbraReverseProxyPortQuery =
        '\(\&\(zimbraServiceHostname=\${MAILHOST}\)\(objectClass=zimbraServer\)\)';
  
  print ZMPROV "mcf zimbraReverseProxyDomainNameQuery $zimbraReverseProxyDomainNameQuery\n";
  print ZMPROV "mcf zimbraReverseProxyMailHostQuery $zimbraReverseProxyMailHostQuery\n";
  print ZMPROV "mcf zimbraReverseProxyPortQuery $zimbraReverseProxyPortQuery\n";
  print ZMPROV "mcf zimbraMemcachedBindPort 11211\n";
  print ZMPROV "mcf zimbraReverseProxyMailHostAttribute zimbraMailHost\n";
  print ZMPROV "mcf zimbraReverseProxyPop3PortAttribute zimbraPop3BindPort\n";
  print ZMPROV "mcf zimbraReverseProxyPop3SSLPortAttribute zimbraPop3SSLBindPort\n";
  print ZMPROV "mcf zimbraReverseProxyImapPortAttribute zimbraImapBindPort\n";
  print ZMPROV "mcf zimbraReverseProxyImapSSLPortAttribute zimbraImapSSLBindPort\n";
  print ZMPROV "mcf zimbraReverseProxyDomainNameAttribute zimbraDomainName\n";
  print ZMPROV "mcf zimbraReverseProxyAuthWaitInterval 10s\n";
  print ZMPROV "mcf zimbraReverseProxyIPLoginLimit 0\n";
  print ZMPROV "mcf zimbraReverseProxyIPLoginLimitTime 3600\n";
  print ZMPROV "mcf zimbraReverseProxyUserLoginLimit 0\n";
  print ZMPROV "mcf zimbraReverseProxyUserLoginLimitTime 3600\n";
}

if ($options{e}) {
  if ($options{m}) {
     print ZMPROV "ms $hostname ".
       "zimbraImapBindPort 7143 "."zimbraImapProxyBindPort 143 ".
       "zimbraImapSSLBindPort 7993 "."zimbraImapSSLProxyBindPort 993 ".
       "zimbraPop3BindPort 7110 "."zimbraPop3ProxyBindPort 110 ".
       "zimbraPop3SSLBindPort 7995 "."zimbraPop3SSLProxyBindPort 995 ".
       "zimbraReverseProxyMailEnabled TRUE ".
       "zimbraImapCleartextLoginEnabled TRUE ".
       "zimbraPop3CleartextLoginEnabled TRUE\n"
  }
  if ($options{w}) {
     print ZMPROV "ms $hostname ".
     "zimbraMailReferMode reverse-proxied ".
     "zimbraMailPort 8080 ".
     "zimbraMailSSLPort 8443 ".
     "zimbraMailMode http ".
     "zimbraMailProxyPort 80 ".
     "zimbraMailSSLProxyPort 443 ".
     "zimbraReverseProxyHttpEnabled TRUE\n";
  }

  print ZMPROV "ms $hostname ".
    "+zimbraServiceEnabled imapproxy\n";
}

if ($options{d}) {
  if ($options{m}) {
     print ZMPROV "ms $hostname ".
       "zimbraImapBindPort 143 "."zimbraImapProxyBindPort 7143 ".
       "zimbraImapSSLBindPort 993 "."zimbraImapSSLProxyBindPort 7993 ".
       "zimbraPop3BindPort 110 "."zimbraPop3ProxyBindPort 7110 ".
       "zimbraPop3SSLBindPort 995 "."zimbraPop3SSLProxyBindPort 7995 ".
       "zimbraReverseProxyMailEnabled FALSE\n";
     if ($options{s}) {
       print ZMPROV "ms $hostname ".
         "zimbraImapCleartextLoginEnabled FALSE ".
         "zimbraPop3CleartextLoginEnabled FALSE\n";
     }
  }
  if ($options{w}) {
     print ZMPROV "ms $hostname ".
       "zimbraMailReferMode wronghost ".
       "zimbraMailPort 80 ".
       "zimbraMailSSLPort 443 ".
       "zimbraMailMode mixed ".
       "zimbraMailProxyPort 0 ".
       "zimbraMailSSLProxyPort 0 ".
       "zimbraReverseProxyHttpEnabled FALSE\n";
  }
  $enabledHTTPProxy = getLdapServerValue("zimbraReverseProxyHttpEnabled");
  $enabledMailProxy = getLdapServerValue("zimbraReverseProxyMailEnabled");
  if ($enabledHTTPProxy eq "FALSE" && $enabledMailProxy eq "FALSE" ) {
     print ZMPROV "ms $hostname ".
       "-zimbraServiceEnabled imapproxy\n";
  }
}

close ZMPROV;
exit 0;

sub usage() {
  print "Usage: $0 [-h] [-m] [-w] [-d [-s]] [-e] [-f] hostname\n";
  print "\t-h: display this help message\n";
  print "\t-d: disable proxy\n";
  print "\t-e: enable proxy\n";
  print "\t-f: Full reset on memcached port and search queries and POP/IMAP throttling.\n";
  print "\t-m: Toggle mail proxy portions\n";
  print "\t-s: Set cleartext to FALSE (secure mode) on disable\n";
  print "\t-w: Toggle Web proxy portions\n";
  print "hostname is the value of the zimbra_server_hostname LC key for the server being modified.\n";
  print "Required options are -f by itself, or -f with -d or -e.\n";
  print "Note that -d or -e require one or both of -m and -w.\n"; 
  exit 1;
}

sub getLdapServerValue {
  my $attrib = shift;
  my ($val,$err);
  my ($rfh,$wfh,$efh,$cmd,$rc);
  $rfh = new FileHandle;
  $wfh = new FileHandle;
  $efh = new FileHandle;
  $cmd = "/opt/zimbra/bin/zmprov -l gs $hostname $attrib";
  my $pid = open3($wfh,$rfh,$efh, $cmd);
  unless(defined($pid)) {
    return undef;
  }
  close $wfh;
  chomp($val = (split(/\s+/, <$rfh>))[-1]);
  chomp($err = join "", <$efh>);
  waitpid($pid,0);
  if ($? == -1) {
    # failed to execute
    return undef;
  } elsif ($? & 127) {
    # died with signal
    return undef;
  } else {
    $rc = $? >> 8;
    return undef if ($rc != 0);
  }

  return $val;
}
